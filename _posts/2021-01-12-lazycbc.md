---
title: Lazy CBC
date: 2021-01-12 00:00 +0200
categories: [CryptoHack, Block Ciphers]
tags: [AES, CBC, key, IV]
---

## Source code

```python
from Crypto.Cipher import AES


KEY = ?
FLAG = ?


@chal.route('/lazy_cbc/encrypt/<plaintext>/')
def encrypt(plaintext):
    plaintext = bytes.fromhex(plaintext)
    if len(plaintext) % 16 != 0:
        return {"error": "Data length must be multiple of 16"}

    cipher = AES.new(KEY, AES.MODE_CBC, KEY)
    encrypted = cipher.encrypt(plaintext)

    return {"ciphertext": encrypted.hex()}


@chal.route('/lazy_cbc/get_flag/<key>/')
def get_flag(key):
    key = bytes.fromhex(key)

    if key == KEY:
        return {"plaintext": FLAG.encode().hex()}
    else:
        return {"error": "invalid key"}


@chal.route('/lazy_cbc/receive/<ciphertext>/')
def receive(ciphertext):
    ciphertext = bytes.fromhex(ciphertext)
    if len(ciphertext) % 16 != 0:
        return {"error": "Data length must be multiple of 16"}

    cipher = AES.new(KEY, AES.MODE_CBC, KEY)
    decrypted = cipher.decrypt(ciphertext)

    try:
        decrypted.decode() # ensure plaintext is valid ascii
    except UnicodeDecodeError:
        return {"error": "Invalid plaintext: " + decrypted.hex()}

    return {"success": "Your message has been received"}

```

From the source code, we can figure out that the `KEY` and the `IV` is the same. After googling a bit you can find this about the [vulnerability](https://crypto.stackexchange.com/questions/16161/problems-with-using-aes-key-as-iv-in-cbc-mode).

## The exploitation

Here is a step by step solution to the problem

1. We need to get the encrypted key. For that we just need to send a blcok of `0` to the server.
2. Append the resulting string to the end of a block of `0` and ask the server to decrypt it.
3. You will get an error message with the plaintext. The last `16-bytes` are the decrypted key.
4. Get the flag hex. Input that and decode the flag.

## Solve script

```python
import requests

url_base = 'http://aes.cryptohack.org/lazy_cbc'

BLOCK_SIZE = 16
ZERO = b'\0' * 16

def hack():
    response = requests.get(url="%s/encrypt/%s" % (url_base, ZERO.hex())).json()

    ciphertext = bytes.fromhex(response['ciphertext'])

    ciphertext = ZERO + ciphertext
    response = requests.get(url="%s/receive/%s" % (url_base, ciphertext.hex())).json()

    plaintext = bytes.fromhex(response['error'][len('Invalid plaintext: '):])
    key = plaintext[BLOCK_SIZE:]

    print(key.hex())

    response = requests.get(url="%s/get_flag/%s" % (url_base, key.hex())).json()
    return bytes.fromhex(response['plaintext']).decode()

if __name__ == '__main__':
    flag = hack()
    print(flag)
```
